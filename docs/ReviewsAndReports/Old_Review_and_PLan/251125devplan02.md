# 251125 Development Plan 02 — Complete Drop-In Agent UX

Goal: Close the gaps identified in `251125GapAnalysis02.md` so any OpenAI Agents SDK module (e.g., Agent Builder exports) dropped under `src/agents/**` is discoverable, secure, tool-governed, and stream-compatible via `/v1/chat/completions` without YAML edits. Scope excludes `examples/` per instruction.

Target UX: drop any OpenAI Agents SDK module (e.g., Agent Builder exports under `src/agents/<Name>/agent.py`) and have it exposed securely via `/v1/chat/completions` without YAML edits or tooling friction.
- Scope: core gateway/runtime (API, registry/discovery, executor, SDK adapter, tooling, security, tests/docs). The `examples/` tree was excluded per request.

Progress Tracker (update as work completes)
- [x] Step 1 — Restore Agents SDK compatibility (dependency + namespace)
- [x] Step 2 — Rebuild SDK adapter for context, upstream, and streaming parity
- [x] Step 3 — Make streaming/tool-call handling OpenAI-compatible for declarative agents
- [x] Step 4 — Enforce gateway tooling governance for SDK tools
- [x] Step 5 — Expand metrics/admin surfaces for tool and discovery visibility
- [x] Step 6 — Fix missing remediation reference and doc alignment

---

## Step 1 — Restore Agents SDK compatibility (dependency + namespace)
**Why:** Agent Builder imports (`Agent`, `function_tool`, `Runner`) fail due to the local `agents` package shadowing the SDK and the SDK dependency being absent, blocking drop-in modules and `use_gateway_tool()`.
**Tasks:**
1) Add the OpenAI Agents SDK dependency to `requirements.txt` (or extras) and verify import availability in runtime and tests.
2) Resolve namespace conflict: either rename the local `agents` package or re-export SDK primitives so `from agents import Agent, function_tool, Runner` works for drop-ins; ensure no breaking changes to internal imports.
3) Update `sdk_adapter.gateway_tools` and `_load_runner` to import SDK symbols explicitly (not via the local package) and fail fast with clear errors if missing.
4) Add a minimal Agent Builder-style fixture and acceptance test that imports `Agent`/`function_tool`/`Runner` from `agents` and runs through `/v1/chat/completions`.
**Exit criteria:** Agent Builder-style drop-ins import and run without code changes; `use_gateway_tool()` resolves `function_tool`; tests cover the compatibility path.

## Step 2 — Rebuild SDK adapter for context, upstream, and streaming parity
**Why:** `_run_openai_agent` flattens messages to a single prompt, ignores the provided upstream client, lacks streaming, and bypasses tool telemetry.
**Tasks:**
1) Convert `ChatCompletionRequest.messages` into SDK `TResponseInputItem` structures (roles, tool_calls, content lists) and pass the full list to `Runner.run` (async) using the gateway-provided OpenAI client.
2) Remove `asyncio.run` anti-patterns; use async execution with proper loop handling and threadpool boundaries where needed.
3) Implement streaming support: forward SDK deltas to HTTP SSE, preserving request IDs and finish signals; fall back gracefully for non-streaming agents.
4) Ensure SDK runs emit gateway metrics/security hooks (upstream call metrics, request context) and honor max tokens/tool hop policies.
5) Add tests for multi-turn context preservation, async agents, streaming deltas, and upstream client usage.
**Exit criteria:** SDK agents mirror Agent Builder behavior (contextful, upstream-bound, streaming-capable) with metrics/security intact; tests pass.

## Step 3 — Make streaming/tool-call handling OpenAI-compatible for declarative agents
**Why:** Current streaming buffers responses and skips tool execution when `stream=true`, so tool_call deltas aren’t honored.
**Tasks:**
1) Stream upstream chunks directly (`client.chat.completions.create(stream=True, ...)`) and encode SSE in order; include tool_call deltas, not just content.
2) When tool_call deltas arrive, invoke `tool_manager` mid-stream and append tool results back into the message stack; gate streaming if tool hops are disabled to avoid silent skips.
3) Maintain backpressure-safe iteration and proper `[DONE]` termination; preserve log context per chunk.
4) Expand tests to assert that tool_call deltas are forwarded during streaming and that tool hops execute in streamed flows (or are explicitly rejected with a clear error).
**Exit criteria:** `/v1/chat/completions` streaming matches OpenAI expectations (content + tool_call deltas); tool loops work or clearly decline in streaming mode; tests cover the flow.

## Step 4 — Enforce gateway tooling governance for SDK tools
**Why:** Native SDK `function_tool` calls bypass gateway metrics/ACLs unless manually wrapped, undercutting centralized observability/security.
**Tasks:**
1) Add a shim/hook to wrap SDK tool executions so they route through `tool_manager` when feasible, recording metrics and enforcing allowlists; document any limits.
2) Provide a clear contract in docs and errors: when native tools cannot be wrapped, require `use_gateway_tool()` for shared tools and surface guidance.
3) Extend metrics to differentiate SDK-origin tool invocations (source label) and ensure AuthContext is applied for SDK tool calls.
4) Add tests that an SDK agent using native tools produces tool_manager metrics/ACL enforcement or fails with actionable guidance.
**Exit criteria:** SDK tool usage is either governed by gateway tooling or explicitly blocked with clear remediation; metrics reflect SDK tool calls; tests validate governance.

## Step 5 — Expand metrics/admin surfaces for tool and discovery visibility
**Why:** Admin metrics omit tool breakdowns and drop-in failure counts, limiting operator visibility.
**Tasks:**
1) Extend `MetricsResponse` and `/admin/metrics` to expose the full `GatewayMetrics.snapshot()` payload, including tool breakdowns and drop-in failure counts.
2) Align Prometheus export fields/labels with the expanded admin shape; ensure backward compatibility for existing dashboards where possible.
3) Update docs (README, relevant guides) with the new metrics fields and example queries; note any breaking changes.
4) Add tests verifying `/admin/metrics` returns tool/discovery data and that Prometheus generation remains valid.
**Exit criteria:** Operators can see tool and discovery health via admin and Prometheus; tests cover the expanded schema.

## Step 6 — Fix missing remediation reference and doc alignment
**Why:** `docs/plans/Gap_Analysis_Report.md` is referenced but absent, creating dead links and unclear alignment.
**Tasks:**
1) Recreate or restore `docs/plans/Gap_Analysis_Report.md` summarizing the current remediation scope, or update all references (e.g., DEVPLAN.md) to the current gap analysis.
2) Ensure the new doc cross-links to `251125GapAnalysis02.md` and this dev plan; state scope exclusions (e.g., `examples/`).
3) Add a short changelog entry/note in the guides or README linking to the live remediation plan.
**Exit criteria:** No dead documentation links; remediation plan is accessible and aligned with current gaps; references updated.

---

Execution Notes
- Keep tests and docs updated per step; run `make test` and `make test-acceptance` after impactful changes.
- Preserve scope: do not edit `examples/`.
- Record any constraints (e.g., unavailable upstream streaming) in docs/tests as explicit behavior.
